代数数据类型: Algebraic Data Type, ADT 



Kotlin没有完整地支持模式匹配，但它的when表达式依旧是一个非常强大的特性



在计算机编程，特别是函数式编程与类型理论中，ADT是一种组合类型（compositetype）。例如，一个类型由其他类型组合而成。两个常见的代数类型是“和”（sum）类型与“积”（product）类型。



ADT是类型安全的



代数是一个很庞大的数学分支，从简单的线性、多项式代数到环、域，再到范畴、函子等更加抽象的代数，越往后发展，代数的抽象级别就越高，同时也越接近事物的本质，当然，其刻画事物的能力也越强。

比如我们提到过的函数式编程思想，它的很多语法特性就是利用了范畴论中的某些思想来实现的



何为“计数”？

我们知道，每种类型在实例化的时候，都会有对应的取值，比如Boolean类型存在两种可能的取值：true或false。如果我们就将数字2与Boolean的取值种类相关联，这种方式就叫作计数。



在ADT中，积类型的表现形式与乘法非常相似，我们可以将其理解为一种组合（combination）。

```kotlin
class BooleanProductUnit(a:Boolean,b:Unit){}
// 计数 = 2 * 1 = 2
```

BooleanProductUnit类最多只能有两种取值，符合我们之前的猜想。

现在你应该可以明白，当我们在利用类进行组合的时候，实际上就是一种product操作，积类型可以看作同时持有某些类型的类型，比如上面的BooleanProduct类型就同时持有Boolean类型和Unit类型。



和类型（sum）顾名思义就对应于代数中的加法。

和类型是类型安全的。

和类型是一种“OR”的关系。积类型是一种“AND”关系。

枚举类是一种和类型，但是和类型在使用的时候功能比较单一，扩展性不强。

我们需要有一种在表达上更强大的语法，那就是在上一章接触到的密封类。



Kotlin 1.0的时候，密封类的子类只能定义在父类结构体中，而Kotlin 1.1之后可以不用将子类定义在父类中了。



ADT在函数式编程中一个非常大的用处，就是结合模式匹配。虽然Kotlin并没有在极大程度上支持模式匹配，然而when表达式依旧是非常强大的一个语言特性。

when表达式结合Kotlin的其他语言特性，比如解构、Smart Casts，已经能够满足大部分工程中的实际需求。



其实在Scala中，模式匹配的核心就是解构。何为解构，简单一点理解就是反向构造某个表达式。



Smart Casts: 使用 is 进行类型判断, 那么就会自动转换为is判断的类型



ADT是类型安全的，当我们使用when表达式的时候，即使遗漏了新类型的逻辑处理，编译器也会提醒我们，将新增的类型补充上去即可。