函数式的纯洁性在于对于一个特定的参数，必定存在一个特定的返回值。所以函数式的执行是无关顺序的。
而在现实世界里，很多东西就必须是有顺序的，比如输入输出。于是Haskell决定用monad去模拟这种操作。monad来源于范畴论，他并不解决副作用问题本身，而是对此类问题提供了抽象。



简单说，Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。



范畴之间的关系被称为函子，函子之间的关系被称为自然变换。



**函数式编程关心类型（代数结构）之间的关系，命令式编程关心解决问题的步骤**



**函数式编程也遵从 数据结构+算法 的约束。**



**函数式编程不仅仅设计函数的复合与代数数据结构，它还提供了对并发计算的支持，这是其他编程范式难以实现的。**



一个名叫[阿隆佐·邱奇](http://zh.wikipedia.org/zh/阿隆佐·邱奇)(Alonzo Church)的年轻数学家就过着这样优越的生活。

阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有[艾伦·图灵](http://zh.wikipedia.org/zh/艾伦·图灵)、[约翰·冯·诺伊曼](http://zh.wikipedia.org/zh/约翰·冯·诺伊曼)、[库尔特·哥德尔](http://zh.wikipedia.org/zh-hant/库尔特·哥德尔)。

这四个人都对形式系统感兴趣。相对于现实世界，他们更关心如何解决抽象的数学问题。而他们的问题都有这么一个共同点：都在尝试解答关于计算的问题。

诸如：如果有一台拥有无穷计算能力的超级机器，可以用来解决什么问题？它可以自动的解决这些问题吗？是不是还是有些问题解决不了，如果有的话，是为什么？如果这样的机器采用不同的设计，它们的计算能力相同吗？

在与这些人的合作下，阿隆佐设计了一个名为[lambda演算](http://zh.wikipedia.org/wiki/Λ演算)的形式系统。这个系统实质上是为其中一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。这种函数用希腊字母lambda（[λ](http://en.wikipedia.org/wiki/Lambda)），这种系统因此得名[4](https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn/blob/master/FunctionalProgrammingForTheRestOfUs.cn.md#f4)。有了这种形式系统，阿隆佐终于可以分析前面的那些问题并且能够给出答案了。

除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为[图灵机](http://zh.wikipedia.org/zh/图灵机)），并用这种系统得出了和阿隆佐相似的答案。

到了后来人们证明了图灵机和lambda演算的能力是一样的。

如果二战没有发生，这个故事到这里就应该结束了，我的这篇小文没什么好说的了，你们也可以去看看有什么其他好看的文章。可是二战还是爆发了，整个世界陷于火海之中。那时的美军空前的大量使用炮兵。为了提高轰炸的精度，军方聘请了大批数学家夜以继日的求解各种差分方程用于计算各种火炮发射数据表。后来他们发现单纯手工计算这些方程太耗时了，为了解决这个问题，各种各样的计算设备应运而生。IBM制造的Mark一号就是用来计算这些发射数据表的第一台机器。Mark一号重5吨，由75万个零部件构成，每一秒可以完成3次运算。

战后，人们为提高计算能力而做出的努力并没有停止。1949年第一台电子离散变量自动计算机诞生并取得了巨大的成功。它是[冯·诺伊曼设计架构](http://zh.wikipedia.org/zh/冯·诺伊曼结构)的第一个实例，也是一台现实世界中实现的图灵机。相比他的这些同事，那个时候阿隆佐的运气就没那么好了。

到了50年代末，一个叫John McCarthy的MIT教授（他也是普林斯顿的硕士）对阿隆佐的成果产生了兴趣。1958年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！很多计算机科学家都认识到了Lisp强大的能力。1973年在MIT人工智能实验室的一些程序员研发出一种机器，并把它叫做Lisp机。于是阿隆佐的lambda演算也有自己的硬件实现了！



λ演算是[图灵完全](https://zh.wikipedia.org/wiki/圖靈完備性)的，也就是说，这是一个可以用于模拟任何[图灵机](https://zh.wikipedia.org/wiki/图灵机)的通用[模型](https://zh.wikipedia.org/wiki/计算模型_(数学))。



函数式编程和我们现在大量使用的过程式编程、面向对象编程一个很大的不同是有些场景下可以由程序的代数性质来推导得到新的程序，通过证明来确保新程序的正确性，不需要测试来验证程序的正确性。测试是不能完全保证正确性的，而推导得到的程序在正确性上则有完全的保证。

**本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。**



驱动编程范式产生巨大变革的力量之一是多核革命。

主流的编程范式——面向对象编程已经难以胜任并发与并行计算领域，它只会造成危险且充满 bug 的设计。

数据隐藏，是面向对象的基本前提，一旦对象被共享且被修改，就会造成数据竞争。

将数据与互斥锁组合起来看似是个不错的解决方案，但不幸的是，互斥锁不能组合，并且一旦在数据竞争中出现死锁，程序非常难以调试。

对于非并发计算，软件系统日益递增的复杂度也正在炙烤着命令式编程范式。

简而言之，副作用正在失去控制。有副作用的函数很便捷又易于编写。

原则上，有副作用的函数所产生的影响可在函数名以及注释中予以标明。

一个叫做 `SetPassword` 或 `WriteFile` 的函数显然在修改某种状态并产生副作用，对此我们已经非常习惯且不以为然。

只有当我们开始将这些有副作用的函数层层组装到一起，事情才开始变得棘手。副作用本身并不坏，但是将它们塞到一个大尺度视图中，我们很难再看清它们，它们便脱离了我们的掌控。

完全与副作用打交道的命令式编程范式才是元凶。



层次化分解与重新复合的过程，并非是受计算机的限制而产生，它反映的是人类思维的局限性。我们的大脑一次只能处理很少的概念。生物学中被广为引用的一篇论文指出我们我们的大脑中只能保存 7± 2 个信息块。我们对人类短期记忆的认识可能会有变化，但是可以肯定的是它是有限的。底线就是我们不能处理一大堆乱糟糟的对象或像兰州拉面似的代码。我们需要结构化并非是因为结构化的程序看上去有多么美好，而是我们的大脑无法有效的处理非结构化的东西。我们经常说一些代码片段是优雅的或美观的，实际上那只意味着它们更容易被人类有限的思维所处理。优雅的代码创造出尺度合理的代码块，它正好与我们的『心智消化系统』能够吸收的数量相符。



对于类型，最简单的直觉就是它是值的集合。`Bool` 类型（记住，Haskell 中具体类型是大写字母开头）是一个含有 2 个元素 `True` 与 `False` 的集合。`Char` 类型是所有 Unicode 字符的集合。

集合可能是有限或无限的。`String` 类型，它与 `Char` 列表同义，它就是个无限集的例子。